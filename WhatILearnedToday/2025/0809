자료 구조(MAP 은 왜 쓸까 등)
Map
	key-value 쌍으로 이루어진 데이터를 저장하는 자료 구조
	해시 테이블을 사용하여 실제 key 값들을 인덱싱하여 조회하기 때문에 시간 조회가 빠름
Set 
	Key 데이터를 저장하는 자료 구조
	Set 안에서 Map 인스턴스(객체)를 사용해서 Map과 동일하게 데이터 조회가 빠름


자바 동시성
자바는 Thread 를 사용해서 작업을 동시, 혹은 병렬 처리할 수 있음
Thread, Syncronized, ConcurrentHashMap 등 정리 필요
왜 Thread 를 쓸까?
==> 요청 흐름과는 별개로, 비동기 작업이나 백그라운드 작업을 수행하려면 Thread를 활용해야한다. 
ex) File 처리와 같이 시간이 오래 걸리는 작업을 MainThread 에서 오래 잡고 있으면 전체 시간이 너무 증가되기 때문에 + 동시에 공유 자원에 접근 제어가 필요한 경우, 
Thread나 Syncronized 를 써야한다. 


객체지향이란? 
세상에 있는 모든 개념이나 속성들을 정의하여 프로그래밍하는 방식입니다.
특성
클래스와 인스턴스(객체)- 클래스는 개념이나 속성 들을 정의한 데이터, 객체는 클래스에서 정의한 것을 실제로 생성하여 메모리에 할당된 것
캡슐화 - 클래스라는 캡슐 안에 접근 제어자를 통한 정보 은닉(private 객체) 해당 클래스에 대한 수정 부분을 외부 모든 곳이 아니라 내부에서 수정할 수 있는 특징이 있음
-캡슐화할 때 접근제어자는 어떻게 활용하며, 이를 사용하지 않았을 때 발생하는 문제는? 
==> 이제 보통 전체가 다 공유해도 괜찮은 속성에 대해서는 public 변수로 두던가, private 변수에 대해 public 한 getter setter를 정의하여 사용하게 합니다. 
- 이를 사용하지 않았을 때는, 불변(immutable)한 객체에 대해서도 set 을 통해 값이 바뀔 수도 있고, 노출되면 안되는 정보마저 노출될 수 있는 위험이 있습니다. 
- 모든 필드에 setter 가 있다면 왜 객체지향설계원칙에 어긋나는지? 이를 개선하기 위해서는? 
==> 모든 필드에 setter 가 존재한다면 불변 객체에 대해서도 변경될 수 있는데, 그렇게 되면 데이터의 무결성이 깨지게 됩니다. 
이를 개선하기 위해서는 불변 객체에 대해 public 한 getter에 대해서만 만들거나, final 키워드를 활용하여 변경되지 않게 하는 방법이 있습니다. 
- 자바에서 불변 객체를 구현할 때 final 키워드를 어떻게 활용하며, 이것이 멀티스레드 환경에서 어떤 이점을 제공한다고 생각하십니까?
==> 예를 들어서 DR 이라는 인물을 객체로 만든다고 할 때, 주민등록번호는 변경되지 않아야 하는 값이니까
이런 속성들은 final String 으로 선언하면 다른 값으로 바꾸는 것 자체가 불가합니다. 
이처럼 final 로 선언된 속성은 객체 생성 단계에서만 설정되기 때문에 동일한 객체를 여러 스레드에서 사용하더라도 동기화 없이 안전하게 사용 가능합니다.
- 생성자에서 this 가 노출되면 어떤 위험이 있는지? 또 어떻게 방지할 수 있는지
==> Event 같은거를 등록할 때 생성자에서 this 를 붙여서 노출시키게 된다면, 객체가 초기화 되기도 이전에 외부에서 초기화가 안된 객체를 사용할 수도 있는 위험이 있습니다. 
이는 팩토리 패턴 같이, private한 객체를 생성하고, 이를 노출시키는 방식을 사용하면 해결됩니다. 
다형성 - 특정 객체가 여러 형태를 갖을 수 있는 특성이고, interface나 클래스를 상속하여 같은 메서드를 사용하더라고 다른 동작을 할 수 있다는 특성입니다.
자바에서는 보통 메서드 오버로딩이나 인터페이스 상속 후 메서드 오버라이딩을 통해 다형성을 실현합니다. 
- 다형성을 사용할 때 업캐스팅과 다운캐스팅의 차이와, 다운캐스팅 시 발생할 수 있는 위험은? 
==> 업캐스팅은 하위 클래스 객체를 상위 클래스 타입으로 참조하는 것으로, 상속 관계에서 자연스럽게 허용됩니다. 이를 통해 상위 타입의 공통 인터페이스로 여러 하위 객체를 다룰 수 있습니다.
다운캐스팅은 상위 클래스 타입의 참조를 다시 하위 클래스 타입으로 변환하는 것으로, 실제 객체가 해당 하위 클래스의 인스턴스일 때만 가능합니다.
만약 실제 타입이 다른데 잘못된 하위 타입으로 캐스팅하면 ClassCastException이 발생합니다. 이 때문에 다운캐스팅 전에는 instanceof를 사용해 타입을 확인하는 것이 안전합니다.
다운캐스팅은 쉽게 List a = ArrayList 로 사용하다가 나중에 (ArrayList) a 이렇게 사용하는 것. => 즉 instance 타입만 맞으면 사용 가능하나 기능이 축소됨

추상 클래스와 interface의 차이점이 무엇이며, 각각을 언제 사용하는지? 
- 추상 클래스는 단일 상속(extends)만 가능하고, 맴버 변수, 일반 메서드와 추상 메서드 모두 존재합니다. 하위 클래스 모두에서 공통된 동작을 일반 메서드에 정의하여 넘겨줄 수 있습니다. 
- interface 는 다중 상속(implements)이 가능하고, 메서드의 시그니처만 정의하고 있습니다. 물론 default method 를 정의하여 상속받는 클래스에서 재정의하거나 정의하지 않도고 사용할 수 있습니다.

- default method 가 추가되었음에도 추상 클래스를 사용해야 하는 경우는? 
==> 추상 클래스는 인스턴스 필드를 가질 수 있어 (메모리에 할당됨), 공통 멤버 변수를 정의하고 이를 기반으로 공통 메서드 로직을 구현할 수 있습니다. 
따라서 공통 상태와 동작을 함께 제공해야 하는 경우에는 추상 클래스를 사용하는 것이 적절합니다.

상속- 자바에서 상속은 extends 나 implements 로 부모 클래스나 인터페이스의 속성과 메서드를 물려받아 재사용하는 것입니다. 
공통 코드를 사용하여 코드의 재사용성을 늘릴 수 있고
다형성을 구현할 수 있는 장점이 있습니다. 
단점으로는 결합도가 높아지면서 유연성과 확장성이 떨어질 수 있습니다.

- 상속보다는 합성을 선호하라는 원칙이 있는데, 왜 그런지와 그 이유를 자바 코드 예시로 설명해주실 수 있나요? 
상속은 부모 클래스의 속성과 동작을 그대로 받아서 사용하게 되어서, 클래스 자체의 유연성이 떨어지게 됩니다. 
합성은 has-a 관계로, 클래스가 다른 객체를 멤버로 포함해 그 기능을을 위임하게 되는 것입니다. 
Engine 을 갖는 자동차 객체가 Engine 을 extends 하기 보다는 Engine 을 멤버로 가지는게 효율적이다. 

추상화- 현실 세계의 개념에서 공통적인 속성과 동작을 추출하여, 불필요한 세부사항을 감추고 핵심만 표현하는 것입니다. 
이를 통해 복잡한 시스템을 단순화하고, 변경에 유연한 구조를 설계할 수 있습니다. 
구현 방법은 abstract class나 interface를 사용하여 구현체가 해야할 공통적인 속성과 동작을 정의하게 할 수 있습니다. 
- 추상화를 지나치게 사용했을 때 발생하는 문제점은? 이를 방지하기 위한 설계 접근 방식은? 
==> 추상화를 불필요하게 사용하면 계층이 늘어나 클래스 수가 과도하게 많아지고, 실제 데이터를 접근·수정하는 과정이 복잡해집니다.
이런 문제를 줄이기 위해 설계 단계에서 객체의 확장 가능성과 공통 로직의 존재 여부를 먼저 분석한 뒤, 필요한 부분에 한해 추상화를 적용하는 것이 좋습니다.
- 추상화와 캡슐화의 차이점과, 각각 어떻게 구현하는지 알려주세요.
==> 캡슐화는 객체의 속성과 동작 등을 하나의 단위로 묶고, 접근 제어자를 통해 외부에서 접근이 필요한 것만 접근하도록 하는 목적이 있습니다. 
추상화는 여러 객체가 공통으로 갖는 특성이나 규약을 정의하는 것입니다. 
예를 들어, class Subway에 몇호선인지, 어떤 역이랑 연결되어 있는지 등의 멤버를 private한 객체로 만들어서 사용하는게 캡슐화라면
interface Vehicle 에 공통 특성들, move, openDoor, stop 등의 메서드를 정의하는 것입니다. 

왜 interface 를 사용해야 할까
- 다형성의 핵심으로, 우리가 어떤 객체를 정의할 때, 인터페이스 타입으로 통일 할 수 있음 
- Loose Coupling(핵심) 느슨한 결합으로 구현체와의 결합도를 낮출 수 있음 
- 유지보수성과 확장 용이성
- 의존성 주입
- 인터페이스를 사용하면, 계층 간의 직접적인 의존을 끊어 긴 결합도를 낮출 수 있음 ==> 안정적인 구조

SOLID 원칙
단일책임원칙 - 클래스는 하나의 책임만 가져야 한다. (변경 이유가 하나여야 한다)
- 반드시 SRP를 지켜야하는 이유를 장기 유지보수 관점에서 설명해라
==> 우선 변경 포인트가 너무 많은 것보다는 하나의 역할만 있을 때 변경하기가 용이하고, 변경 사항이 다른 역할의 코드에도 영향을 줄 가능성이 적어집니다.
또한 공통 코드들을 모듈로 만든다고 할때에도 타 프로젝트에 영향성을 줄이기 위해서는 단일 책임을 갖는 클래스들을 유지해야 합니다. 

개방-폐쇄 원칙 - 개방-폐쇄 원칙은 기능 확장에는 열려 있고, 기존 코드 변경에는 닫혀 있어야 한다는 원칙입니다.
예를 들어 Animal 인터페이스에 move() 메서드를 정의하고, Dog와 Cat이 각각 이를 구현합니다. 
상위 코드에서는 Animal 타입만 의존하므로, 새로운 Bird 클래스를 추가하더라도 기존 코드를 수정할 필요 없이 확장만으로 기능을 추가할 수 있습니다. 
이렇게 하면 변경으로 인한 리스크를 줄이고, 유지보수성을 높일 수 있습니다.
if-else나 switch-case로 구현체를 구분하면, 새로운 타입이 추가될 때마다 조건문과 각 구현부를 모두 수정해야 합니다. 이는 변경 포인트가 여러 곳으로 늘어나 유지보수성이 떨어지고, 실수로 특정 분기에서 구현체를 누락할 위험도 커집니다.
OCP를 지키기 위해서는 상위 타입(인터페이스 또는 추상 클래스)에만 의존하도록 하고, 구체적인 동작은 하위 구현체에 위임합니다. 이렇게 하면 새로운 구현체를 추가하더라도 상위 코드나 호출부를 수정할 필요 없이 확장만으로 기능을 추가할 수 있습니다.

리스코프 치환 원칙 - 리스코프 치환 원칙은 하위 클래스가 상위 클래스의 규약을 지키면서 언제나 상위 타입으로 대체 가능해야 한다는 원칙입니다. 
즉, 상위 클래스의 인스턴스를 사용하는 코드가 하위 클래스 인스턴스로 바뀌더라도, 프로그램의 동작이 깨지면 안 됩니다. 
이를 위해 하위 클래스는 상위 클래스의 메서드 시그니처와 계약(계약적 동작, 사전·사후 조건, 불변식)을 지켜야 합니다.
ex) 사각형 클래스를 마름모 클래스가 상속하고 있다고 했을 때, 
사각형 클래스에서는 넓이를 width * height 로 하는데 마름모는 대각선 * 대각선 / 2 인데
마름모 클래스를 우리가 사각형 클래스로 대체했을 때 넓이가 달라지는거라 이런 구조를 가져가면 안된다는 의미

인터페이스 분리 원칙 - 인터페이스 분리 원칙은 범용적인 큰 인터페이스 하나보다, 작고 목적이 명확한 인터페이스 여러 개로 나누는 것을 권장하는 원칙입니다. 
이렇게 하면 구현체가 자신이 사용하지 않는 불필요한 메서드를 구현하지 않아도 됩니다.
예를 들어 어떤 클래스가 수영과 농구를 모두 한다면 Swimmer 인터페이스에는 swim() 메서드만, Hooper 인터페이스에는 shoot() 메서드만 정의하고, 
해당 기능이 필요한 클래스만 이를 구현하도록 합니다.
만약 하나의 거대한 Athlete 인터페이스에 swim()과 shoot()가 모두 있다면, 수영만 하는 클래스도 농구 관련 메서드를 구현해야 하는 불필요한 의존성이 생깁니다.(불필요한 의존성을 없애는게 핵심)

의존성 역전 원칙 - 의존 역전 원칙은 상위 모듈이 하위 모듈의 구체 구현에 의존하지 않고, 상위와 하위 모두 추상화(인터페이스나 추상 클래스)에 의존해야 한다는 원칙입니다.
예를 들어 상위 모듈은 PaymentService 인터페이스 타입만 참조하고, 하위 모듈들은 CardPayment, KakaoPay처럼 해당 인터페이스를 구현합니다. 
이렇게 하면 상위 모듈이 하위 구현체에 직접 의존하지 않아도 되어, 새로운 결제 방식이 추가될 때도 기존 상위 모듈을 수정할 필요가 없습니다.
이 방식은 모듈 간 결합도를 낮추고, 코드 계층을 분리해 유지보수와 확장성을 높이는 장점이 있습니다.

오버로딩이랑 오버라이딩의 차이
오버로딩- 같은 리턴 타입을 갖는 동일한 이름의 메서드를 매개변수의 차이를 두게 하는 것
오버라이딩- abstract 클래스나, interface 에서 정의한 메서드를 이를 상속하는 클래스에서 재정의하여 사용하는 것

JVM, GC
JVM은 Java Virtual Machine 자바 가상 머신으로, 컴파일된 코드를 실행하는 역할.
.java -> Run/Build -> Java Complier(javac) -> .java to byte Code -> 가상 머신에서 프로그램 실행
GC(Garbage Collector)- 유효하지 않는 메모리를 제거해주는 역할
C언어를 쓸때는 메모리 alloc, free 해서 데이터가 들어갈 공간을 만들고, 폐기하는 과정이 있는데
자바에서는 기본형 변수(int, char, boolean 등) 제외하고 new 로 객체 데이터를 만들어서 넣으면 폐기하는 과정은 없음 ==> GC가 해줌
+ 개발자가 System.gc() 를 호출해서 gc 를 돌리는 경우는 거의 없을 것으로 생각
+ 다만, 생명주기를 보고 메모리가 낭비되고 있는지는 확인이 필요함 (안드로이드에서는 GlobalScope 나 Service() 클래스 영역에서 발생하기 쉬움)
 
SQL injection 을 어떻게 방지할 수 있을까?
쿼리를 문자열로 받지 말고, API 파라미터로 받고 서버에서는 DTO를 사용하여 바인딩해서 실행하도록? 


DB기본
기본키와 고유키 차이
**기본 키(Primary Key)**는 테이블의 각 행을 고유하게 식별하는 키로, 한 테이블에 하나만 설정할 수 있고, NULL 값을 가질 수 없습니다. 자동으로 고유 인덱스가 생성됩니다.
**고유 키(Unique Key)**는 특정 컬럼 값의 중복을 막지만, 하나의 테이블에 여러 개 생성할 수 있고 NULL 값을 허용합니다(단, DBMS별로 동작 차이가 있음).
즉, 기본 키는 레코드 식별을 위한 주 식별자이고, 고유 키는 유일성 보장을 위한 보조 식별자입니다.

인덱스를 사용하는 이유
인덱스는 데이터를 빠르게 조회하기 위해 사용하는 자료구조로, 주로 B-Tree나 Hash 구조를 사용합니다. 
인덱스를 만들면 전체 테이블을 스캔하는 대신 인덱스 트리를 탐색해 원하는 데이터 위치를 바로 찾을 수 있어 조회 속도가 크게 향상됩니다.
하지만 인덱스는 디스크 공간을 추가로 차지하고, INSERT/UPDATE/DELETE 시 인덱스도 함께 수정되어 쓰기 성능이 떨어질 수 있습니다.

JOIN의 종류를 설명해주세요
교집합에 해당하는 INNER / OUTER LEFT/RIGHT(조건이 맞지 않아도 한쪽 테이블의 행을 전부 포함) / UNION (전체 조인)

정규화(Normalization)가 무엇이며, 장단점은 무엇인가요?
데이터 중복을 최소화하고 데이터 무결성을 유지하기 위해 테이블 구조를 체계적으로 분해하는 과정입니다.
주로 관계형 데이터베이스 설계 단계에서 수행하며, 이상 현상(Anomaly)을 방지합니다.
실무에서는 3NF까지 정규화 후, 성능이 필요한 부분에 한해 비정규화를 적용합니다.

트랜잭션의 4대 특성을 설명하고, 실무에서는 이를 보장하기 위해 어떤 방법을 사용하는지? 
원자성: 트랜잭션 내 모든 작업이 수행되거나 전혀 수행되지 않아야함.
일관성: 트랜잭션 전후로 데이터의 무결성을 만족해야함.
격리성: 동시에 실행되는 트랜잭션이 서로 영향을 주지 않도록 보장해야함.
지속성: 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장됨
ACID는 원자성·일관성·격리성·지속성을 의미하며, 
DBMS의 트랜잭션 관리와 애플리케이션의 트랜잭션 경계 설정(@Transactional)로 보장합니다. 
실무에서는 성능과 데이터 무결성 사이에서 Isolation Level을 조정하고, 동시성 제어 기법을 함께 사용합니다.

복합 인덱스
복합 인덱스는 두 개 이상의 컬럼을 순서 있게 묶어 만든 인덱스로, 컬럼 순서에 따라 사용 가능 여부가 달라집니다. 
자주 함께 조회되거나 정렬되는 컬럼 조합에 사용하면 쿼리 성능을 크게 향상시킬 수 있습니다.
컬럼 순서는 값의 다양성이 더 높은 컬럼을 먼저 두는 것이 일반적입니다. 그래야 인덱싱이 더 넓은 범위로 지정되기 때문입니다. 
장점
다중 조건 검색 속도 향상
다중 컬럼 정렬 최적화 가능
자주 함께 조회되는 컬럼 묶음에 적합
주의점
컬럼 순서 잘못 설정하면 효과 반감
너무 많은 컬럼을 인덱스에 넣으면 인덱스 크기 증가 → 쓰기(INSERT/UPDATE/DELETE) 성능 저하
사용 패턴 분석 후 필요한 최소 컬럼만 구성

스키마는 컬럼 구조를 의미
관계형 DB, NoSQL 차이
RDBMS: 관계형 데이터 모델로 테이블 - 행 - 열 구조를 갖고, 고정된 구조를 갖고 SQL로 데이터를 조작합니다. 
- 조인(Join) 가능, 복잡한 관계형 연산에 강점
- EPR처럼 강한 데이터 무결성이 필요한 곳
NoSQL: 비관계형 데이터 모델로, 키-값, 문서 등 다양한 모델을 갖습니다.  또한 필드 추가 및 변경이 자유로워 스키마가 유연한 장점이 있습니다 
- 조인 기능 제한적, 대신 데이터 중복 저장 허용해 조회 성능 극대화
- 로그 저장, 실시간 분석, 소셜 피드, IoT, 대규모 분산 캐시

REST API / GraphQL
REST API: GET, POST, PUT, DELETE 같은 HTTP 메서드를 활용하여 인터넷을 통해 정보를 안전하게 교환하기 위한 인터페이스
- 앤드포인트 별로 고정된 응답
- 필요한 앤티디, 형식에 따라 다수의 앤드포인트
- 클라이언트-서버 역할을 명확히 분리
- 무상태성(Stateless) 서버는 클라이언트의 상태를 세션에 저장하지 않음 
- HTTP 메서드, JSON/XML 형태의 응답값 등 일관된 인터페이스 사용
GraphQL: 퀴리 기반 API 스펙으로, 클라이언트가 필요한 데이터 구조를 직접 정의하여 서버에 요청하는 방식을 사용 ==> 하나의 앤드포인트에서 다양한 데이터 조회 가능
- 필요한 데이터만 요청 가능, 관계형 데이터도 한번의 요청으로 가져올 수 있음

URL vs URI
URL은 Uniform Resource Locator로, 인터넷 상의 자원의 위치를 나태내는 문자열 ( 그 자체로도 URI 를 할 수 있음 (URI가 더 상위 개념) ) 
URI는 Uniform Resource Identifier 로 인터넷 상의 자원의 식별자
GraphQL은 하나의 앤드포인트 (하나의 URL)에 여러 응답이 와서 캐싱이 어렵지만
REST API는 하나의 앤드포인트에 하나의 결과 데이터가 있기 때문에 캐싱이 쉬움

Spring MVC 구조 vs DDD(Domain Driven Design) vs Hexagonal Architechture 
- controller / model (service(비즈니스 로직), repository(DB 접근), domain(Entity, DTO)) / view (View, Thymeleaf/JSP 등)
- 다만 View 를 vue 나 react 같이 HTML을 직접 작성하지 않는다면 프론트앤드에서 서버 응답을 받아 그리게 됨


Vue를 사용해보셨다고 하셨는데 어떻게 사용하셨는지 Vue 에 대해서 좀 설명해주실 수 있으신가요?
- 반응형 구조를 갖춘 프론트앤드 프레임워크로, 
1) 싱글파일 컴포넌트인 Vue 컴포넌트에 HTML Template + JavaScript + CSS 를 한 파일에 작성해서 사용
2) Vuex를 통해 상태 관리를 하고, Vue Router 를 통해서 페이지 라우팅을 함


대규모 트래픽이 들어오면 어떻게 대처할건지


StringBuilder 와 StringBuffer의 차이점


Split vs StringTokenizer 
- Split 을 실무에서 많이 사용하지만 StringTokenizer 가 단순 고정 구분자에 대한 빠른 처리 측면에서는 더 나음


WebServer, NAS, WAS, Proxy Server 
Web Server - 클라이언트의 요청을 받아 HTML, CSS 과 같은 정적 컨텐츠를 제공하는 서버
	- HTTP 기반 요청 처리, 정적 파일 제공, 간단한 라우팅 및 리다이랙션, WAS에 요청하는 게이트웨어 역할도 함
	- Apache HTTP Server, NginX, Microsoft IIS 
NginX - Apache 서버는 Connection에 대해 매번 새로운 Process 를 만들어서 메모리 부하가 있었음. --> NginX는 connection을 효율적으로 처리하는 서버
	- NginX는 자체 방화벽은 아니고, 방화벽과 연동하여 보안을 강화한다. ==> 백엔드 서버의 IP를 숨기고 보안을 강화
	- allow, deny 설정으로 특정 IP만 허용/차단 가능, User-Agent 차단, 요청 필터링, 보안 헤더 추가, HTTPS 적용, 
Proxy Server - 클라이언트와 서버 사이의 중간에서 요청을 중계하는 서버
WAS - Web Application Server 
	- 백앤드 애플리케이션이 실행하는 서버라고 볼 수 있음 
	- 비즈니스 로직이나, 데이터 처리 등을 진행
	- 사용자 요청 -> 웹 서버 -> WAS -> 데이터베이스 -> WAS -> 웹 서버 -> 사용자
NAS - Network Attached Storage
	- 네트워크에 연결되는 저장장치. 
	- 단순 하드웨어 장치는 아니고, 자체적으로 OS와 CPU가 있는 서버가 있음
	- 방화벽이 존재하여 보안 처리도 가능
	
클라우드 컴퓨팅
