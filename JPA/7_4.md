## 도메인 분석 설계

#### 가본 용어 정리
- 도메인: 일반적인 요구사항, 소프트웨어로 해결하고자 하는 문제 영역
- 도메인 모델: 특정 도메인을 개념적으로 표현한 것
- 테이블 설계 시 다대다 관계를 1대다 다대1 관계로 푸는게 좋고, 양방향 연관 관계도 단일 방향으로 바꾸는게 좋다. 

#### DDD(Domain Driven Development) 정의/특징
- DDD는, 도메인 패턴을 중심에 놓고 설계하는 방식을 일컫는다. 
- 도메인 그 자체와, 도메인 로직에 초점을 맞춘다. 데이터 중심의 접근법이 아닌, 도메인 모델과 로직에 집중하는 것을 말한다. 
- 보편적인(ubiquitous) 언어의 사용. 단일화된 언어체계를 구축하여 커뮤티케이션이 가능케 한다.
- 소프트웨어 엔티이와 모데인 컨셉트를 가능한 가장 가까이 일치시키는 것이다. 

#### 왜 DDD를 사용하는가? 
- 도메인 모델의 적용 범위를 구현까지 확장하여 도메인 지식을 구현 코드에 반영한다. 
- 각각의 도메인 별 구현을 하기 때문에 MSA를 적용하는데 용이하다!! 

#### 도메인 모델과 테이블 설계

![image](https://user-images.githubusercontent.com/24373728/177063150-95564f81-0691-44f7-888a-1c729ccc35a6.png)

- 일반적인 도메인 모델의 예시이다.
- 다대다 관계를 정확히 작성하고, 모델들의 관계를 파악하자.
- 도메인 모델을 가지고 실제 엔터티 분석을 진행한다. 

![image](https://user-images.githubusercontent.com/24373728/177063200-dca578d1-bd78-432e-9ed8-29d15d52c596.png)

- 도메인 모델을 각각의 엔티티로 만들어서 다시 표현한다. 
- 다대다 관계를 풀어낼 땐, 중간 테이블을 하나 만들어야 한다. 

![image](https://user-images.githubusercontent.com/24373728/177063672-888b3e36-9220-4887-bb62-7017e4404363.png)

- 카테고리 엔티티를 보면, 중간에 CATEGORY_ITEM 엔티티를 추가하여 다대다 관계를 1대다 다대1 관계로 바꾸었다.
- 참고, 엔티티를 설계할 때 기업마다 다르지만, 대문자/소문자 + _ (언더스코프)를 사용한다.
- 일관성 있게 엔티티를 작성하자. (소문자 + _ )

##### 연관관계 매핑 분석
- 일대다, 대다일 관계에서 연관관계의 주인을 정해야 한다.
- 외래키가 있는 테이블을 주인으로 세팅하는게 좋다. 
- 외래키가 가까운 곳에 있는 엔티티를 주인으로 해야 모든게 편하다! 절대 비즈니스적 우위로 선택하는 것이 아니다.
- 주인을 잘못 선정하면 필요 없는 관리와 유지보수, 그리고 업데이트 쿼리가 발생하여 성능 문제가 발생한다!

#### 엔티티 클래스 개발
- 실제 설계 시 Getter는 열고, Setter는 가급적 열지 않는게 좋다. 허가 없는 데이터의 번경을 막기 위해! 

#### 테이블 설계 시 유의사항
- JPA를 통해 H2 DB를 만들었다면, 우리가 선택한 외부 라이브러리로 인해 DB 생성 관련 Script가 조회 가능하다.
- 이를 똑같이 쓰지 말고, 이를 참고하여 DDL을 튜닝하고, 테이블을 생성해서 사용하자. 

### 엔터티 설계 주의점
#### 엔터티에는 가급적 Setter를 사용하지 말자.
- 변경 포인트가 많아져 유지보수가 어려워진다

#### 모든 연관관계는 지연로딩으로 설정
- 즉시로딩(EAGER)은, 어떤 테이블을 로딩하는 시점에 연관된 모든 데이터를 가져오는 방법
- 실무에서 모든 연관관계는 지연로딩(LAZY)으로 설정해야 한다.
- 연관된 엔티팅를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
- @XToOne 관계는 기본이 즉시로딩이다. 직접 지연로딩으로 설정해야 한다. 
- 단, @XToMany 관계는 지연로딩이 기본값이다. 

#### 컬렌션은 필드에서 초기화 하자
- 컬렉션은 필드에서 바로 초기화 하는 것이 안전하다
```JAVA
public class Category {

    ....

    @OneToMany(mappedBy = "parent")
    private List<Category> child = new ArrayList<>();
    
}
```
- Hibernate는 엔티티를 영속화할 때 컬랙션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 
- 이때 우리가 임의로 컬렌션 자체를 수정하거나 변경하려고 하면 매커니즘 호환성 문제로 인해 문제가 발생할 수 있고,
- 가급적 필드에서 초기화하고, 메서드나 어떤 로직을 통해 변경을 하지 않는게 좋다.

#### 테이블, 컬럼명 생성 전략
file:///C:/Users/HD/Desktop/study/JPA%20%EA%B0%95%EC%9D%98%20%EC%9E%90%EB%A3%8C.pdf




#### 어노테이션 정리
- @Id
- @GeneratedValue
- @Embedded
- @Embeddable
- @OneToMany
- @ManyToOne
- @JoinColumn
- @JoinTable
- @Enumerated(EnumType.STRING)
- @Inheritance
- @DiscriminatorColumn
- @DiscriminatorValue("")
